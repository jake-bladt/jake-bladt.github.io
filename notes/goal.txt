Ultimately, what I want to do is build software that solves real problems - not "how do I connect restaurants with take-out customers" problems - more like "how do we get clean, potable water to people who don't have it?" and "how do we use the Internet to make education available to people who don't have electricity?"

Ten years ago, I was a .net developer with a little bit of JavaScript, a little bit of Python, and a big pile of knowledge relating to obsolete, proprietary systems. Those skills were good enough to keep me working indefinitely, but they weren't the skills I would need to build the kind of software I wanted to write.

When you write software that isn't primarily designed for making money, you have to ask different questions than when you write propietary systems for your employer. There's a virtuous cycle to writing for-profit software: you pay to run it. It brings in money to keep it running. If you do it well and you're lucky, it brings in a surplus - enough to give you time to build bigger and better systems. Your primary design question is, "How do I write this to cost less than it brings in?"

When you write software that's meant to improve the human condition, the primary question is: How can I keep this running for as little money as possible for as long as possible? How can I solve more problems on less hardware? 

If you can't outrun your cost through profitability, it changes your whole outlook on building software. Commercial licenses, vendor lock-in, and forced obsolescence become deal-killers. You start looking to FOSS software running on commodity hardware.

In fairness to Microsoft, their embrace of FOSS in recent years has opened up a world of possibilities for changing the world with software running on the Windows platform. Back in the early aughts, Redmond's embrace of FOSS was much more tepid than it is now. I decided that, if I were going to build the systems I really wanted to, I would need to step out of the Microsoft creche and relearn how to get from an idea to a production system using only FOSS tools.

I learned Java and the JVM. I dusted off my Python, up until then used primarily as a glue language for automation. With the advent of Node, I dug into JavaScript beyond what I'd learned from Dynamic Drive. I continued to work primarily with C# because those were the easiest jobs to find. But, with each new project, I used more FOSS tools.

In 2010, I got lucky. I was contracted for a job in C#, but the managers decided it was going to be written in Java instead. I wasn't ready to get a job on the strength of my Java yet, but having been hired, I was able to roll with the language change and to parlay that experience into a contract to write Android apps. The next long-term job after that started in C#, but I got to work in Ruby on Rails, Clojure, and Java, automating Apache Kafka, Storm, and Cassandra.

As my confidence in FOSS tools grew, I started to build small systems using them, which helped me figure out what I still needed to know in order to build the software I imagined. I was pretty strong on programming languages, databases, messaging, architecture, but poor in design and deployment.

Design may be a lost cause, but I'd already started to dip my toe into the waters of deployment. I'd spent a couple of years writing software for the cloud and being the "de facto deployment guy" for my teams.

When a chance to take a devops role appeared, I jumped on it. The first reason was that it was a chance to fill in the biggest gap in my knowledge of the SDLC. The second was that I would only be working in places that believed in devops.

===

DRAFT 2

I spent most of my first fifteen years of my professional life writing systems to help make rich people richer - trading systems, portfolio management applications, and the like - tools that big banks need to move money efficiently and retain customers. The software that I wrote solved interesting problems and changed the world in ways far larger than I could do by hand.

Since then, my career decisions have focused on building up my skillset to the point where I can build software that addresses real, human problems like access to clean, potable water. That's meant focusing more on open license tools running on commodity hardware and filling the gaps where my knowledge of the full software development lifecycle have been the weakest.

To that end, I've been a developer, architect, project manager, and most recently devops engineer. Each role gave me fresh insight into another part of getting software from concept to completion.
